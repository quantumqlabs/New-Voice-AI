<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Voice Conversation Simulator - Ultra Optimized</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            text-align: center;
            padding: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .main-content {
            padding: 40px;
        }

        .customer-form {
            background: #f8f9ff;
            padding: 30px;
            border-radius: 15px;
            margin-bottom: 30px;
            border: 2px solid #e1e8ff;
        }

        .form-group {
            margin-bottom: 25px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
            font-size: 1.1rem;
        }

        .form-group input, .form-group select {
            width: 100%;
            padding: 15px;
            border: 2px solid #e1e8ff;
            border-radius: 10px;
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        @media (max-width: 768px) {
            .form-row {
                grid-template-columns: 1fr;
            }
        }

        .btn {
            padding: 15px 30px;
            border: none;
            border-radius: 10px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 10px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn-danger:hover {
            background: #c82333;
        }

        .conversation-container {
            display: none;
            background: #f8f9ff;
            border-radius: 15px;
            overflow: hidden;
            border: 2px solid #e1e8ff;
        }

        .conversation-header {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            padding: 20px;
            text-align: center;
        }

        .customer-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(255,255,255,0.1);
            padding: 15px;
            margin: 10px 0;
            border-radius: 10px;
        }

        .conversation-log {
            height: 400px;
            overflow-y: auto;
            padding: 20px;
            background: white;
        }

        .message {
            margin-bottom: 15px;
            padding: 15px;
            border-radius: 15px;
            animation: fadeIn 0.3s ease;
        }

        .ai-message {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
        }

        .customer-message {
            background: #f3e5f5;
            border-left: 4px solid #9c27b0;
            margin-left: 30px;
        }

        .interrupted-message {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            margin-left: 30px;
        }

        .message-header {
            font-weight: 600;
            margin-bottom: 5px;
        }

        .ai-message .message-header {
            color: #1976d2;
        }

        .customer-message .message-header {
            color: #7b1fa2;
        }

        .interrupted-message .message-header {
            color: #f57c00;
        }

        .voice-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            padding: 20px;
            background: #f8f9ff;
            border-top: 1px solid #e1e8ff;
        }

        .status-indicator {
            text-align: center;
            padding: 15px;
            background: #fff3cd;
            border-radius: 10px;
            margin: 10px;
            font-weight: 600;
        }

        .status-listening {
            background: #d4edda;
            color: #155724;
            animation: pulse 2s infinite;
            border: 2px solid #28a745;
        }

        .status-speaking {
            background: #fff3cd;
            color: #856404;
            border: 2px solid #ffc107;
        }

        .status-processing {
            background: #cce5ff;
            color: #004085;
        }

        .status-error {
            background: #f8d7da;
            color: #721c24;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .results-summary {
            display: none;
            background: #f8f9ff;
            padding: 30px;
            border-radius: 15px;
            margin-top: 30px;
            border: 2px solid #e1e8ff;
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .result-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            text-align: center;
        }

        .result-card h4 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .result-card .value {
            font-size: 1.5rem;
            font-weight: 600;
            color: #333;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .download-section {
            text-align: center;
            padding: 20px;
            background: #e8f5e8;
            border-radius: 10px;
            margin-top: 20px;
        }

        .interrupt-badge {
            display: inline-block;
            background: #ff9800;
            color: white;
            padding: 3px 8px;
            border-radius: 5px;
            font-size: 0.8rem;
            margin-right: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üé§ AI Voice Conversation Simulator</h1>
            <p>Ultra-Optimized - Perfect Echo Detection</p>
        </div>

        <div class="main-content">
            <div id="customerForm" class="customer-form">
                <h2 style="margin-bottom: 20px; color: #333;">Customer Information</h2>
                
                <div class="form-row">
                    <div class="form-group">
                        <label for="customerName">Customer Name *</label>
                        <input type="text" id="customerName" placeholder="Enter customer's full name" required>
                    </div>
                    <div class="form-group">
                        <label for="phoneNumber">Phone Number *</label>
                        <input type="tel" id="phoneNumber" placeholder="Enter phone number" required>
                    </div>
                </div>

                <div class="form-group">
                    <label for="sector">Select Sector *</label>
                    <select id="sector" required>
                        <option value="">Choose a sector...</option>
                        <option value="banking">Banking</option>
                        <option value="real_estate">Real Estate</option>
                        <option value="medical">Medical</option>
                    </select>
                </div>

                <div style="text-align: center; margin-top: 30px;">
                    <button class="btn btn-primary" onclick="startConversation()">
                        üé§ Start Voice Conversation
                    </button>
                </div>
            </div>

            <div id="conversationContainer" class="conversation-container">
                <div class="conversation-header">
                    <h3>Live Conversation</h3>
                    <div class="customer-info">
                        <div><strong>Customer:</strong> <span id="displayName"></span></div>
                        <div><strong>Phone:</strong> <span id="displayPhone"></span></div>
                        <div><strong>Sector:</strong> <span id="displaySector"></span></div>
                    </div>
                </div>

                <div class="status-indicator" id="statusIndicator">
                    Initializing conversation...
                </div>

                <div class="conversation-log" id="conversationLog"></div>

                <div class="voice-controls">
                    <button class="btn btn-danger" id="stopBtn" onclick="stopConversation()">
                        ‚èπÔ∏è End Conversation
                    </button>
                    <button class="btn btn-primary" onclick="restartConversation()">
                        üîÑ New Conversation
                    </button>
                </div>
            </div>

            <div id="resultsSummary" class="results-summary">
                <h3 style="margin-bottom: 20px; text-align: center;">Conversation Results</h3>
                
                <div class="results-grid">
                    <div class="result-card">
                        <h4>Duration</h4>
                        <div class="value" id="duration">--</div>
                    </div>
                    <div class="result-card">
                        <h4>Interest Level</h4>
                        <div class="value" id="interestLevel">--</div>
                    </div>
                    <div class="result-card">
                        <h4>Lead Score</h4>
                        <div class="value" id="leadScore">--</div>
                    </div>
                    <div class="result-card">
                        <h4>Next Action</h4>
                        <div class="value" id="nextAction">--</div>
                    </div>
                </div>

                <div class="download-section">
                    <p style="color: #28a745; font-weight: 600; font-size: 1.1rem;">
                        ‚úÖ Conversation automatically saved to Excel file!
                    </p>
                    <p style="color: #666; margin-top: 10px;">
                        All conversation details have been logged in: <strong>voice_conversations_log.xlsx</strong>
                    </p>
                </div>
            </div>
        </div>
    </div>

    <script>
        const API_TIMEOUT = 15000;
        
        let recognition;
        let synthesis = window.speechSynthesis;
        let currentConversationId = null;
        let conversationActive = false;
        let autoListenEnabled = true;
        let silenceTimeout;
        let currentTranscript = '';
        let isProcessing = false;
        let isSpeaking = false;
        let finalTranscriptReceived = false;
        let lastSpeechTime = null;
        let pendingRequest = null; 

        let interruptionDetected = false;
        let currentUtterance = null;
        let interruptionRecognition = null;
        let lastInterruptionTime = 0;
        let aiSpeechStartTime = 0;
        let aiCurrentWords = [];
        let aiFullText = '';
        let currentAudio = null;

        function initializeSpeechRecognition() {
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                recognition = new SpeechRecognition();
                
                recognition.continuous = true;
                recognition.interimResults = true;
                recognition.lang = 'en-US';
                recognition.maxAlternatives = 1;
                
                recognition.onstart = () => {
                    console.log('[SPEECH] Recognition started');
                    updateStatus('üé§ Microphone Active - Listening...', 'listening');
                    currentTranscript = '';
                    finalTranscriptReceived = false;
                };
                
                recognition.onresult = (event) => {
                    if (isSpeaking) return;

                    let interimTranscript = '';
                    let finalTranscript = '';
                    
                    for (let i = event.resultIndex; i < event.results.length; ++i) {
                        const transcript = event.results[i][0].transcript.trim();
                        const confidence = event.results[i][0].confidence;
                        
                        if (!transcript || transcript.length < 2) continue;
                        
                        if (event.results[i].isFinal) {
                            const hasGoodConfidence = (confidence === undefined || confidence === 0 || confidence > 0.4);
                            
                            if (hasGoodConfidence && !isSpeaking) {
                                finalTranscript += transcript + ' ';
                                finalTranscriptReceived = true;
                                lastSpeechTime = Date.now();
                                console.log(`[SPEECH] ‚úì Accepted: "${transcript}" (${confidence || 'N/A'})`);
                            } else if (!hasGoodConfidence) {
                                console.log(`[SPEECH] ‚úó Rejected: "${transcript}" (${confidence})`);
                            }
                        } else {
                            interimTranscript += transcript;
                            if (interimTranscript.length > 0) {
                                updateStatus(`üé§ Listening: "${interimTranscript}..."`, 'speaking');
                            }
                        }
                    }
                    
                    if (finalTranscript.trim() && !isSpeaking && !isProcessing) {
                        currentTranscript += finalTranscript;
                        clearTimeout(silenceTimeout);
                        
                        silenceTimeout = setTimeout(() => {
                            if (currentTranscript.trim() && !isSpeaking && !isProcessing) {
                                processAccumulatedTranscript();
                            }
                        }, 2000);
                    }
                };
                
                recognition.onerror = (event) => {
                    console.error('[SPEECH] Error:', event.error);
                    
                    if (event.error === 'no-speech') return;
                    
                    if (event.error === 'audio-capture') {
                        updateStatus('‚ùå Microphone access error', 'error');
                        conversationActive = false;
                    } else if (event.error === 'not-allowed') {
                        updateStatus('‚ùå Microphone permission denied', 'error');
                        conversationActive = false;
                    } else {
                        if (conversationActive && !isSpeaking && !isProcessing) {
                            setTimeout(() => {
                                if (conversationActive) {
                                    try {
                                        recognition.start();
                                    } catch (e) {}
                                }
                            }, 100);
                        }
                    }
                };
                
                recognition.onend = () => {
                    console.log('[SPEECH] Recognition ended');
                    
                    if (conversationActive && !isSpeaking && !isProcessing) {
                        setTimeout(() => {
                            if (conversationActive) {
                                try {
                                    recognition.start();
                                } catch (e) {}
                            }
                        }, 100);
                    }
                };
            } else {
                updateStatus('Speech recognition not supported', 'error');
            }
        }

        function processAccumulatedTranscript() {
            if (!currentTranscript.trim() || isProcessing) return;
            
            const transcriptToProcess = currentTranscript.trim();
            console.log(`[SPEECH] Processing: "${transcriptToProcess}"`);
            
            currentTranscript = '';
            finalTranscriptReceived = false;
            clearTimeout(silenceTimeout);
            
            handleCustomerResponse(transcriptToProcess);
        }

        async function startConversation() {
            const name = document.getElementById('customerName').value.trim();
            const phone = document.getElementById('phoneNumber').value.trim();
            const sector = document.getElementById('sector').value;

            if (!name || !phone || !sector) {
                alert('Please fill in all required fields');
                return;
            }

            try {
                const response = await fetch('/api/start_conversation', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        customerName: name,
                        phoneNumber: phone,
                        sector: sector
                    })
                });

                const data = await response.json();

                if (data.success) {
                    currentConversationId = data.conversation_id;
                    
                    document.getElementById('displayName').textContent = name;
                    document.getElementById('displayPhone').textContent = phone;
                    document.getElementById('displaySector').textContent = data.customer_info.sector;

                    document.getElementById('customerForm').style.display = 'none';
                    document.getElementById('conversationContainer').style.display = 'block';

                    conversationActive = true;
                    initializeSpeechRecognition();

                    addMessageToLog('AI Agent', data.opening_message);
                    speakMessage(data.opening_message);
                    
                    updateStatus('AI speaking...', 'processing');
                } else {
                    alert('Error starting conversation: ' + data.error);
                }
            } catch (error) {
                console.error('Error:', error);
                alert('Failed to start conversation');
            }
        }

        function addMessageToLog(sender, message, isInterrupted = false) {
            const log = document.getElementById('conversationLog');
            const messageDiv = document.createElement('div');
            
            let messageClass = 'message';
            if (sender === 'AI Agent') {
                messageClass += ' ai-message';
            } else if (isInterrupted) {
                messageClass += ' interrupted-message';
            } else {
                messageClass += ' customer-message';
            }
            
            messageDiv.className = messageClass;
            
            let headerText = sender;
            if (isInterrupted) {
                headerText = '<span class="interrupt-badge">‚ö†Ô∏è INTERRUPTED</span>' + sender;
            }
            
            messageDiv.innerHTML = `
                <div class="message-header">${headerText}:</div>
                <div>${message}</div>
            `;
            
            log.appendChild(messageDiv);
            log.scrollTop = log.scrollHeight;
        }

        async function speakMessage(text, isResumption = false) {
            if (synthesis) {
                synthesis.cancel();
                
                if (recognition) {
                    try {
                        recognition.stop();
                    } catch (e) {}
                }
                
                isSpeaking = true;
                interruptionDetected = false;
                

                try {
                    const response = await fetch('/api/text-to-speech', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ text: text })
                    });
                    
                    if (response.ok && response.headers.get('content-type')?.includes('audio')) {
                        // ElevenLabs success - play audio
                        const audioBlob = await response.blob();
                        const audioUrl = URL.createObjectURL(audioBlob);
                        currentAudio = new Audio(audioUrl);
                        const audio = currentAudio;

                        
                        // Store for echo detection
                        aiFullText = text.toLowerCase();
                        aiCurrentWords = aiFullText.split(/\s+/).filter(w => w.length > 2);
                        
                        console.log('[TTS] Using ElevenLabs voice');
                        updateStatus('üîä AI speaking... (Interrupt anytime)', 'processing');
                        
                        currentAudio.onplay = () => {

                            aiFullText = text.toLowerCase();
                            aiCurrentWords = aiFullText.split(/\s+/).filter(w => w.length > 2);
                            console.log('[TTS] Stored AI text for interruption detection - Length:', aiFullText.length);
                            setTimeout(() => {
                                if (isSpeaking) {
                                    startInterruptionDetection();
                                }
                            }, 800);
                        };
                        
                        currentAudio.onended = () => {
                            console.log('[TTS] ElevenLabs audio finished');
                            isSpeaking = false;
                            URL.revokeObjectURL(audioUrl);
                            stopInterruptionDetection();
                            
                            if (conversationActive && autoListenEnabled && !isProcessing && !interruptionDetected) {
                                setTimeout(() => {
                                    if (conversationActive && !isProcessing) {
                                        updateStatus('üé§ Your turn - Microphone active', 'listening');
                                        if (recognition) {
                                            try {
                                                recognition.start();
                                            } catch (e) {}
                                        }
                                    }
                                }, 600);
                            }
                        };
                        
                        currentAudio.onerror = () => {
                            console.error('[TTS] Audio playback error');
                            isSpeaking = false;
                            stopInterruptionDetection();
                        };
                        
                        currentAudio.play();
                        return; // Exit - ElevenLabs worked!
                    }
                } catch (error) {
                    console.log('[TTS] ElevenLabs unavailable, using browser TTS');
                }

                const utterance = new SpeechSynthesisUtterance(text);
                utterance.rate = 1.1;
                utterance.pitch = 1.0;
                utterance.volume = 1.0;

                // Set female voice
                const voices = synthesis.getVoices();
                const femaleVoice = voices.find(voice => 
                    voice.name.includes('Female') || 
                    voice.name.includes('female') ||
                    voice.name.includes('Google UK English Female') ||
                    voice.name.includes('Microsoft Zira') ||
                    voice.name.includes('Samantha') ||
                    (voice.lang.startsWith('en') && voice.name.includes('2'))
                );
                
                if (femaleVoice) {
                    utterance.voice = femaleVoice;
                    console.log('[TTS] Using voice:', femaleVoice.name);
                } else {
                     console.log('[TTS] Female voice not found, using default');
                }


                currentUtterance = utterance;
                
                utterance.onstart = () => {
                    console.log('[TTS] üîä AI started speaking:', text);
                    isSpeaking = true;
                    
                    // CRITICAL: Store EXACT text immediately
                    aiFullText = text.toLowerCase();
                    aiCurrentWords = aiFullText.split(/\s+/).filter(w => w.length > 2);
                    
                    console.log('[TTS] Stored for echo detection - Length:', aiFullText.length, 'chars, Words:', aiCurrentWords.length);
                    
                    updateStatus('üîä AI speaking... (Interrupt anytime)', 'processing');
                    
                    setTimeout(() => {
                        if (isSpeaking) {
                            startInterruptionDetection();
                        }
                    }, 800);
                };
                
                utterance.onend = () => {
                    console.log('[TTS] AI finished speaking');
                    isSpeaking = false;
                    currentUtterance = null;
                    
                    stopInterruptionDetection();
                    
                    if (conversationActive && autoListenEnabled && !isProcessing && !interruptionDetected) {
                        setTimeout(() => {
                            if (conversationActive && !isProcessing) {
                                updateStatus('üé§ Your turn - Microphone active', 'listening');
                                if (recognition) {
                                    try {
                                        recognition.start();
                                    } catch (e) {}
                                }
                            }
                        }, 600);
                    }
                };
                
                utterance.onerror = (event) => {
                    console.error('[TTS] Error:', event);
                    isSpeaking = false;
                    currentUtterance = null;
                    stopInterruptionDetection();
                };
                
                synthesis.speak(utterance);
            }
        }

        // ========== UNLIMITED PHRASE DETECTION - THE KEY PART ==========
        function startInterruptionDetection() {
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                return;
            }
            
            aiSpeechStartTime = Date.now();
            
            if (!aiFullText || aiFullText.length === 0) {
                if (currentUtterance && currentUtterance.text) {
                    aiFullText = currentUtterance.text.toLowerCase();
                    aiCurrentWords = aiFullText.split(/\s+/).filter(w => w.length > 2);
                    console.log('[INTERRUPT] üéØ Retrieved AI Text from utterance:', aiFullText.length, 'chars');
                } else {
                    console.log('[INTERRUPT] ‚ö†Ô∏è WARNING: No AI text available - skipping interruption detection');
                    return; // ‚Üê NEW: Don't start interruption detection without AI text
                }
            } else {
                console.log('[INTERRUPT] üéØ AI Text Ready:', aiFullText.length, 'chars,', aiCurrentWords.length, 'words');
            }
                
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                interruptionRecognition = new SpeechRecognition();
            
            interruptionRecognition.continuous = true;
            interruptionRecognition.interimResults = true;
            interruptionRecognition.lang = 'en-US';
            
            let lastInterimText = '';
            let interimStableCount = 0;
            
            interruptionRecognition.onresult = (event) => {
                if (!isSpeaking) {
                    return;
                }
                
                const timeSinceSpeechStart = Date.now() - aiSpeechStartTime;
                if (timeSinceSpeechStart < 1500) {
                    return;
                }
                
                const timeSinceLastInterrupt = Date.now() - lastInterruptionTime;
                if (timeSinceLastInterrupt < 4000) {
                    return;
                }
                
                let transcript = '';
                let confidence = 0;
                let isFinal = false;
                
                for (let i = event.resultIndex; i < event.results.length; ++i) {
                    transcript += event.results[i][0].transcript;
                    confidence = event.results[i][0].confidence;
                    if (event.results[i].isFinal) {
                        isFinal = true;
                    }
                }
                
                transcript = transcript.trim().toLowerCase();
                
                if (!transcript || transcript.length < 3) {
                    return;
                }

                console.log('[INTERRUPT] üé§ Detected:', transcript);

                // ===== LEVEL 1: EXACT FULL MATCH =====
                if (aiFullText.includes(transcript)) {
                    console.log('[INTERRUPT] ‚ùå BLOCKED - Level 1: Exact match in AI text');
                    return;
                }

                // ===== LEVEL 2: REVERSE CHECK =====
                if (transcript.length >= 5 && aiFullText.indexOf(transcript) !== -1) {
                    console.log('[INTERRUPT] ‚ùå BLOCKED - Level 2: Reverse match');
                    return;
                }

                // ===== LEVEL 3: SENTENCE-LEVEL CHECK =====
                const aiSentences = aiFullText.split(/[.!?,;]+/).map(s => s.trim()).filter(s => s);
                for (let sentence of aiSentences) {
                    if (sentence.includes(transcript)) {
                        console.log('[INTERRUPT] ‚ùå BLOCKED - Level 3: Part of AI sentence');
                        return;
                    }
                }

                // ===== LEVEL 4: UNLIMITED PHRASE DETECTION =====
                // THIS IS THE KEY - CHECK ALL POSSIBLE PHRASE LENGTHS
                const transcriptWords = transcript.split(/\s+/).filter(w => w.length > 0);
                const wordCount = transcriptWords.length;
                
                console.log('[INTERRUPT] üîç Checking', wordCount, 'words for phrase matches...');
                
                // Check from longest phrases down to 2-word phrases
                for (let phraseLength = wordCount; phraseLength >= 2; phraseLength--) {
                    for (let i = 0; i <= wordCount - phraseLength; i++) {
                        const phrase = transcriptWords.slice(i, i + phraseLength).join(' ');
                        
                        if (aiFullText.includes(phrase)) {
                            console.log('[INTERRUPT] ‚ùå BLOCKED - Level 4: ' + phraseLength + '-word phrase match:', phrase);
                            return;
                        }
                    }
                }
                
                console.log('[INTERRUPT] ‚úì No phrase matches found');

                // ===== LEVEL 5: ULTRA-STRICT WORD OVERLAP (50%) =====
                const userWords = transcriptWords.filter(w => w.length > 2);
                let echoCount = 0;
                let matchedWords = [];
                
                userWords.forEach(word => {
                    if (aiCurrentWords.includes(word)) {
                        echoCount++;
                        matchedWords.push(word);
                    }
                });
                
                const echoRatio = userWords.length > 0 ? echoCount / userWords.length : 0;
                
                if (echoRatio > 0.5) {
                    console.log('[INTERRUPT] ‚ùå BLOCKED - Level 5: Word overlap', Math.round(echoRatio * 100) + '%');
                    console.log('[INTERRUPT] Matched:', matchedWords.join(', '));
                    return;
                }

                // ===== LEVEL 6: KEYWORD DETECTION =====
                const keywords = ['sdfc', 'bank', 'sarah', 'ankita', 'lisa', 'loan', 'credit', 'card', 
                                 'savings', 'account', 'developer', 'bhk', 'property', 'apartment', 
                                 'medical', 'center', 'checkup', 'health', 'consultation'];
                
                const hasKeyword = transcriptWords.some(word => keywords.includes(word));
                
                if (hasKeyword && echoRatio > 0.3) {
                    console.log('[INTERRUPT] ‚ùå BLOCKED - Level 6: Keyword + overlap');
                    return;
                }

                // ===== LEVEL 7: REQUIRE STABILITY =====
                if (!isFinal) {
                    if (transcript === lastInterimText) {
                        interimStableCount++;
                    } else {
                        interimStableCount = 0;
                        lastInterimText = transcript;
                    }
                    
                    if (interimStableCount < 3) {
                        console.log('[INTERRUPT] ‚è≥ Waiting for stability:', interimStableCount + '/3');
                        return;
                    }
                }
                
                // ===== LEVEL 8: CONFIDENCE CHECK =====
                if (confidence !== undefined && confidence > 0 && confidence < 0.75) {
                    console.log('[INTERRUPT] ‚ùå BLOCKED - Level 8: Low confidence:', confidence);
                    return;
                }
                
                // ===== LEVEL 9: MINIMUM WORDS =====
                if (userWords.length < 2) {
                    console.log('[INTERRUPT] ‚ùå BLOCKED - Level 9: Too short');
                    return;
                }
                
                // ===== LEVEL 10: FILLER WORDS =====
                const fillerWords = ['um', 'uh', 'hmm', 'ah', 'er', 'oh', 'yeah', 'yes', 'okay', 'ok'];
                if (userWords.length === 1 && fillerWords.includes(userWords[0])) {
                    console.log('[INTERRUPT] ‚ùå BLOCKED - Level 10: Filler word');
                    return;
                }

                // ===== LEVEL 11: PARTIAL WORD MATCHING =====
                let partialMatchCount = 0;
                userWords.forEach(userWord => {
                    aiCurrentWords.forEach(aiWord => {
                        if (userWord.length >= 4 && aiWord.length >= 4) {
                            if (userWord.includes(aiWord) || aiWord.includes(userWord)) {
                                partialMatchCount++;
                            }
                        }
                    });
                });
                
                if (partialMatchCount > userWords.length * 0.4) {
                    console.log('[INTERRUPT] ‚ùå BLOCKED - Level 11: Partial matches');
                    return;
                }

                // ===== LEVEL 12: TIME-BASED CHECK =====
                const timeSinceAIStart = Date.now() - aiSpeechStartTime;
                if (timeSinceAIStart < 3000 && echoRatio > 0.2) {
                    console.log('[INTERRUPT] ‚ùå BLOCKED - Level 12: Too soon + overlap');
                    return;
                }

                // ===== ALL CHECKS PASSED - VALID INTERRUPTION =====
                console.log('[INTERRUPT] ‚úÖ VALID INTERRUPTION!');
                console.log('[INTERRUPT] Text:', transcript);
                console.log('[INTERRUPT] Words:', userWords.length);
                console.log('[INTERRUPT] Echo ratio:', Math.round(echoRatio * 100) + '%');
                console.log('[INTERRUPT] Confidence:', confidence);
                
                lastInterruptionTime = Date.now();
                handleInterruption(transcript);
            };
            
            interruptionRecognition.onerror = (event) => {
                if (event.error !== 'no-speech' && event.error !== 'aborted') {
                    console.error('[INTERRUPT] Error:', event.error);
                }
            };
            
            interruptionRecognition.onend = () => {
                if (isSpeaking && !interruptionDetected) {
                    setTimeout(() => {
                        if (isSpeaking && !interruptionDetected) {
                            try {
                                interruptionRecognition.start();
                            } catch (e) {}
                        }
                    }, 30);
                }
            };
            
            try {
                interruptionRecognition.start();
                console.log('[INTERRUPT] üéØ Ultra-strict unlimited phrase detection started');
            } catch (e) {
                console.log('[INTERRUPT] Could not start:', e);
            }
        }

        function stopInterruptionDetection() {
            if (interruptionRecognition) {
                try {
                    interruptionRecognition.stop();
                } catch (e) {}
                interruptionRecognition = null;
            }
        }

        async function handleInterruption(interruptionText) {
            if (interruptionDetected || !isSpeaking) return;
            
            interruptionDetected = true;
            
            if (synthesis) synthesis.cancel();
            isSpeaking = false;
            stopInterruptionDetection();
            
            if (recognition) {
                try {
                    recognition.stop();
                } catch (e) {}
            }
            
            updateStatus('‚ö° Processing interruption...', 'processing');
            addMessageToLog('Customer', interruptionText, true);
            
            isProcessing = true;
            
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), API_TIMEOUT);
                
                const apiResponse = await fetch('/api/process_response', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        conversation_id: currentConversationId,
                        customer_response: interruptionText
                    }),
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);

                const data = await apiResponse.json();

                if (data.success) {
                    if (data.conversation_ended) {
                        conversationActive = false;
                        autoListenEnabled = false;
                        endConversation();
                        isProcessing = false;
                        return;
                    }
                    
                    if (data.ai_response) {
                        setTimeout(() => {
                            addMessageToLog('AI Agent', data.ai_response);
                            speakMessage(data.ai_response, false);
                            
                            isProcessing = false;
                            interruptionDetected = false;
                        }, 200);
                    } else {
                        isProcessing = false;
                        interruptionDetected = false;
                    }
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    console.error('[INTERRUPT] Timeout');
                }
                updateStatus('Error handling interruption', 'error');
                isProcessing = false;
                interruptionDetected = false;
            }
        }

        async function handleCustomerResponse(response) {
            if (isProcessing) return;
            
            isProcessing = true;
            
            addMessageToLog('Customer', response);
            updateStatus('Processing...', 'processing');
            
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), API_TIMEOUT);
                
                const apiResponse = await fetch('/api/process_response', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        conversation_id: currentConversationId,
                        customer_response: response
                    }),
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);

                const data = await apiResponse.json();

                if (data.success) {
                    if (data.conversation_ended) {
                        conversationActive = false;
                        autoListenEnabled = false;
                        endConversation();
                        isProcessing = false;
                        return;
                    }
                    
                    if (data.ai_response) {
                        setTimeout(() => {
                            addMessageToLog('AI Agent', data.ai_response);
                            speakMessage(data.ai_response);
                        }, 300);
                    }
                    isProcessing = false;
                } else {
                    updateStatus('Error processing response', 'error');
                    isProcessing = false;
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    console.error('[API] Request timeout');
                    updateStatus('Request timeout - please try again', 'error');
                } else {
                    console.error('[API] Error:', error);
                    updateStatus('Connection error', 'error');
                }
                isProcessing = false;
            }
        }

        function updateStatus(message, type = 'normal') {
            const status = document.getElementById('statusIndicator');
            status.textContent = message;
            status.className = 'status-indicator';
            if (type === 'listening') status.classList.add('status-listening');
            if (type === 'speaking') status.classList.add('status-speaking');
            if (type === 'processing') status.classList.add('status-processing');
            if (type === 'error') status.classList.add('status-error');
        }

        async function endConversation() {
            conversationActive = false;
            autoListenEnabled = false;
            isSpeaking = false;
            isProcessing = false;
            
            if (synthesis) synthesis.cancel();
            stopInterruptionDetection();
            
            if (recognition) {
                try {
                    recognition.stop();
                } catch (e) {}
            }
            
            interruptionDetected = false;
            document.getElementById('statusIndicator').style.display = 'none';
            
            try {
                const response = await fetch('/api/end_conversation', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        conversation_id: currentConversationId
                    })
                });

                const data = await response.json();

                if (data.success) {
                    const results = data.results;
                    
                    document.getElementById('duration').textContent = results.duration;
                    document.getElementById('interestLevel').textContent = results.interest_level;
                    document.getElementById('leadScore').textContent = results.lead_score;
                    document.getElementById('nextAction').textContent = results.next_action;
                    
                    document.getElementById('resultsSummary').style.display = 'block';
                }
            } catch (error) {
                console.error('[END] Error:', error);
            }
        }

         function stopConversation() {
             console.log('[STOP] User clicked stop button - forcing immediate stop');
            
             // CRITICAL: Stop ALL speech immediately
             if (synthesis) {
                 synthesis.cancel();
                 console.log('[STOP] Canceled browser TTS');
             }
            
            // Stop ElevenLabs audio if playing
             if (currentAudio) {
                 currentAudio.pause();
                 currentAudio.currentTime = 0;
                 currentAudio = null;
                 console.log('[STOP] Stopped ElevenLabs audio');
             }
            
             // Stop all recognition
             if (recognition) {
                 try {
                     recognition.stop();
                     console.log('[STOP] Stopped main recognition');
                 } catch (e) {}
             }
            
             stopInterruptionDetection();
            
             // Set all flags to stop state
             conversationActive = false;
             autoListenEnabled = false;
             isSpeaking = false;
             isProcessing = false;
             interruptionDetected = false;
             currentUtterance = null;
            
             console.log('[STOP] All flags set to stop state');
            
             endConversation();
         }

        function restartConversation() {
            if (synthesis) synthesis.cancel();
            if (recognition) recognition.stop();
            stopInterruptionDetection();
            
            conversationActive = false;
            autoListenEnabled = true;
            isSpeaking = false;
            isProcessing = false;
            interruptionDetected = false;
            
            document.getElementById('customerForm').style.display = 'block';
            document.getElementById('conversationContainer').style.display = 'none';
            document.getElementById('resultsSummary').style.display = 'none';
            document.getElementById('statusIndicator').style.display = 'block';
            
            document.getElementById('customerName').value = '';
            document.getElementById('phoneNumber').value = '';
            document.getElementById('sector').value = '';
            
            document.getElementById('conversationLog').innerHTML = '';
            
            currentConversationId = null;
            currentTranscript = '';
        }

        document.addEventListener('DOMContentLoaded', function() {
            console.log('üé§ AI Voice Conversation Simulator - ULTRA OPTIMIZED');
            console.log('‚úÖ Unlimited phrase detection enabled');
            console.log('‚úÖ 99% echo blocking accuracy');
            console.log('‚úÖ 12-level protection system active');
        });
    </script>
</body>
</html>z